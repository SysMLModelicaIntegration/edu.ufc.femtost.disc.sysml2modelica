--
--  Copyright (c) 2013 Jean-Marie Gauthier and University of Franche-Comte
--  All rights reserved. This program and the accompanying materials
--  are made available under the terms of the Eclipse Public License v1.0
--  which accompanies this distribution, and is available at
--  http://www.eclipse.org/legal/epl-v10.html
--  
--  Contributors:
--      Jean-Marie Gauthier and University of Franche-Comte - initial API and implementation
--

-- @nsURI MMmodelica=http://www.femto-st.fr/disc/Modelica.ecore
-- @nsURI MMsysml=http://www.eclipse.org/papyrus/sysml/1.4/SysML
-- @nsURI MMuml=http://www.eclipse.org/uml2/5.0.0/UML
-- @nsURI MMmodelicaProfile=http://www.femto-st.fr/disc/SysML4Modelica

module omgsysml2modelica;
create OUTmodelica : MMmodelica from INuml : MMuml, INsysml : MMsysml, INmodelicaProfile: MMmodelicaProfile;

-----------------------------------------------------------------------
-------------------------------HELPERS----------------------------------
------------------------------------------------------------------------
helper def: Sequence2String(seq: Sequence(String), size: Integer) : String = 
	if(seq.size() <> 0) then 
		if(size = seq.size()) then
			seq.at(size).toString()
		else
			thisModule.Sequence2String(seq, size + 1).concat(', '+seq.at(size).toString())
		endif
	else
		''
	endif;

helper def: isBlockStereotyped(c: MMuml!Class) : Boolean = 
	c.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML::Blocks::Block');

helper def: isConstraintBlockStereotyped(c: MMuml!Class) : Boolean = 
	c.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML::Constraints::ConstraintBlock');

----------------
---DEPRECATED---
----------------
helper def: isFlowPortStereotyped(p: MMuml!Port) : Boolean = 
	p.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML::PortAndFlows::FlowPort');

helper context MMuml!DataType def: isValueTypeStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML::Blocks::ValueType');

helper context MMuml!NamedElement def: isModelicaClassDefinitionStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | 
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaClass' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaModel' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaRecord' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaBlock' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaPackage' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaConnector' or
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaOperator' or 
		s.qualifiedName = 'SysML4Modelica::Classes::ModelicaType'
	);

helper context MMuml!NamedElement def: isModelicaComponentStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | 
		s.qualifiedName = 'SysML4Modelica::Components::ModelicaValueProperty' or
		s.qualifiedName = 'SysML4Modelica::Components::ModelicaPart' or
		s.qualifiedName = 'SysML4Modelica::Components::ModelicaPort'
	);

helper context MMuml!NamedElement def: isModelicaClassStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaClass');

helper context MMuml!NamedElement def: isModelicaModelStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaModel');

helper context MMuml!NamedElement def: isModelicaRecordStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaRecord');

helper context MMuml!NamedElement def: isModelicaBlockStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaBlock');

helper context MMuml!NamedElement def: isModelicaConnectorStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaConnector');

helper context MMuml!NamedElement def: isModelicaPackageStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaPackage');

helper context MMuml!NamedElement def: isModelicaTypeStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaType');

helper context MMuml!NamedElement def: isModelicaFunctionStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaFunction');

helper context MMuml!NamedElement def: isModelicaFunctionParameterStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Components::ModelicaFunctionParameter');

helper context MMuml!Dependency def: isModelicaDerStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaDer');

helper context MMuml!Dependency def: isModelicaConstrainedByStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaConstrainedBy');

helper context MMuml!Generalization def: isModelicaExtendsStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Classes::ModelicaExtends');

helper context MMuml!Property def: isModelicaValuePropertyStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Components::ModelicaValueProperty');

helper context MMuml!Property def: isModelicaPartStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Components::ModelicaPart');

helper context MMuml!Property def: isModelicaPortStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Components::ModelicaPort');

helper context MMuml!Connector def: isModelicaConnectionStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Equations And Algorithms::ModelicaConnection');

helper context MMuml!Constraint def: isModelicaEquationStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Equations And Algorithms::ModelicaEquation');

helper context MMuml!Behavior def: isModelicaAlgorithmStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Equations And Algorithms::ModelicaAlgorithm');

helper context MMuml!Comment def: isModelicaAnnotationStereotyped() : Boolean = 
	self.getAppliedStereotypes()->exists(s | s.qualifiedName = 'SysML4Modelica::Other::ModelicaAnnotation');


helper context MMuml!Class def: getIsFinal() : Boolean = 
	MMmodelicaProfile!ModelicaClassDefinition.allInstances()->select(mc | mc.base_Classifier = self)->first().isFinal;

helper context MMuml!Property def: getIsFinal() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
		union(MMmodelicaProfile!ModelicaPart.allInstances())->
			union(MMmodelicaProfile!ModelicaPort.allInstances())->
				select(mc | 
					if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty) or mc.oclIsTypeOf(MMmodelicaProfile!ModelicaPart))then
						mc.base_Property = self
					else
						mc.base_Port = self
					endif
				)->first().isFinal;

helper context MMuml!FunctionBehavior def: getIsFinal() : Boolean = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().isFinal;

helper context MMuml!Parameter def: getIsFinal() : String = 
	MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().isFinal;

helper context MMuml!DataType def: getIsFinal() : String = 
	MMmodelicaProfile!ModelicaType.allInstances()->select(mt | mt.base_DataType = self)->first().isFinal;

helper context MMuml!Class def: getIsPartial() : Boolean = 
	MMmodelicaProfile!ModelicaClassDefinition.allInstances()->select(mc | mc.base_Classifier = self)->first().isPartial;

helper context MMuml!FunctionBehavior def: getIsPartial() : Boolean = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().isPartial;

helper context MMuml!DataType def: getIsPartial() : Boolean = 
	MMmodelicaProfile!ModelicaType.allInstances()->select(mt | mt.base_DataType = self)->first().isPartial;

helper context MMuml!Generalization def: getModification() : String = 
	thisModule.Sequence2String(MMmodelicaProfile!ModelicaExtends.allInstances()->select(mc | mc.base_Generalization = self)->first().modification, 1);

helper context MMuml!Parameter def: getModification() : String = 
	thisModule.Sequence2String(MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().modification, 1);

helper context MMuml!Dependency def: getModification() : String = 
	thisModule.Sequence2String(MMmodelicaProfile!ModelicaConstrainedBy.allInstances()->select(mc | mc.base_Dependency = self)->first().modification, 1);

helper context MMuml!Property def: getModification() : String = 
	thisModule.Sequence2String(
		MMmodelicaProfile!ModelicaValueProperty.allInstances()->
			union(MMmodelicaProfile!ModelicaPart.allInstances())->
				union(MMmodelicaProfile!ModelicaPort.allInstances())->
					select(mc | 
						if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty) or mc.oclIsTypeOf(MMmodelicaProfile!ModelicaPart))then
							mc.base_Property = self
						else
							mc.base_Port = self
						endif
					)->first().modification, 1);

helper context MMuml!Class def: getIsReplaceable() : Boolean = 
	MMmodelicaProfile!ModelicaClassDefinition.allInstances()->select(mc | mc.base_Classifier = self)->first().isReplaceable;

helper context MMuml!FunctionBehavior def: getIsReplaceable() : Boolean = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().isReplaceable;

helper context MMuml!Parameter def: getIsReplaceable() : String = 
	MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().isReplaceable;

helper context MMuml!DataType def: getIsReplaceable() : String = 
	MMmodelicaProfile!ModelicaType.allInstances()->select(mt | mt.base_DataType = self)->first().isReplaceable;

helper context MMuml!Property def: getIsReplaceable() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
		union(MMmodelicaProfile!ModelicaPart.allInstances())->
			union(MMmodelicaProfile!ModelicaPort.allInstances())->
				select(mc | 
					if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty) or mc.oclIsTypeOf(MMmodelicaProfile!ModelicaPart))then
						mc.base_Property = self
					else
						mc.base_Port = self
					endif
				)->first().isReplaceable;

helper context MMuml!Property def: getCausality() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
			union(MMmodelicaProfile!ModelicaPort.allInstances())->
				select(mc | 
					if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty))then
						mc.base_Property = self
					else
						mc.base_Port = self
					endif
				)->first().causality;

helper context MMuml!Parameter def: getCausality() : String = 
	MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().causality;

helper context MMuml!Generalization def: getVisibility() : String = 
	MMmodelicaProfile!ModelicaExtends.allInstances()->select(mc | mc.base_Generalization = self)->first().visibility;

helper context MMuml!Property def: getVisibility() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->select(mc | mc.base_Property = self)->first().visibility;

helper context MMuml!Generalization def: getArraySize() : String = 
	thisModule.Sequence2String(MMmodelicaProfile!ModelicaExtends.allInstances()->select(mc | mc.base_Generalization = self)->first().arraySize, 1);

helper context MMuml!Property def: getArraySize() : Sequence(String) = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
		union(MMmodelicaProfile!ModelicaPart.allInstances())->
			union(MMmodelicaProfile!ModelicaPort.allInstances())->
				select(mc | 
					if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty) or mc.oclIsTypeOf(MMmodelicaProfile!ModelicaPart))then
						mc.base_Property = self
					else
						mc.base_Port = self
					endif
				)->first().arraySize;

helper context MMuml!Parameter def: getArraySize() : String = 
	thisModule.Sequence2String(MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().arraySize, 1);

helper context MMuml!Class def: getIsModelicaEncapsulated() : Boolean = 
	MMmodelicaProfile!ModelicaClassDefinition.allInstances()->select(mc | mc.base_Classifier = self)->first().isModelicaEncapsulated;

helper context MMuml!DataType def: getIsModelicaEncapsulated() : Boolean = 
	MMmodelicaProfile!ModelicaType.allInstances()->select(mt | mt.base_DataType = self)->first().isModelicaEncapsulated;

helper context MMuml!FunctionBehavior def: getIsModelicaEncapsulated() : Boolean = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().isModelicaEncapsulated;

helper context MMuml!Class def: getIsExpandable() : Boolean = 
	MMmodelicaProfile!ModelicaConnector.allInstances()->select(mc | mc.base_Classifier = self)->first().isExpandable;

helper context MMuml!FunctionBehavior def: getIsExpandable() : Boolean = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().isExpandable;

helper context MMuml!Property def: getVariability() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->select(mc | mc.base_Property = self)->first().variability;

helper context MMuml!Parameter def: getVariability() : String = 
	MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().variability;

helper context MMuml!FunctionBehavior def: getExternalLibrary() : Sequence(String) = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().externalLibrary;

helper context MMuml!FunctionBehavior def: getExternalInclude() : String = 
	MMmodelicaProfile!ModelicaFunction.allInstances()->select(mc | mc.base_FunctionBehavior = self)->first().externalInclude;

helper context MMuml!Dependency def: getVariable() : String = 
	MMmodelicaProfile!ModelicaDer.allInstances()->select(mc | mc.base_Dependency = self)->first().variable;

helper context MMuml!Property def: getConditionalExpression() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
		union(MMmodelicaProfile!ModelicaPart.allInstances())->
			union(MMmodelicaProfile!ModelicaPort.allInstances())->
				select(mc | 
					if(mc.oclIsTypeOf(MMmodelicaProfile!ModelicaValueProperty) or mc.oclIsTypeOf(MMmodelicaProfile!ModelicaPart))then
						mc.base_Property = self
					else
						mc.base_Port = self
					endif
				)->first().conditionalExpression;


helper context MMuml!Parameter def: getDeclarationEquation() : String = 
	MMmodelicaProfile!ModelicaFunctionParameter.allInstances()->select(mc | mc.base_Parameter = self)->first().declarationEquation;


helper context MMuml!Property def: getFlowFlag() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->select(mc | mc.base_Property = self)->first().flowFlag;

helper context MMuml!Property def: getScope() : String = 
	MMmodelicaProfile!ModelicaValueProperty.allInstances()->
		union(MMmodelicaProfile!ModelicaPart.allInstances())->
				select(mc | mc.base_Property = self)->first().scope;

helper context MMuml!NamedElement def: getWithinClause(): String =
		if (self.owner.oclIsTypeOf(MMuml!Model)) then 
			self.owner.name
    	else 
    		if(self.owner.oclIsTypeOf(MMuml!Package)) then
				self.owner.getWithinClause().concat('/'.concat(self.owner.name))
    		else
    			self.owner.getWithinClause().concat('/'.concat(self.owner.name))
			endif
		endif;

helper context MMuml!Constraint def: getIsInitial() : String = 
	MMmodelicaProfile!ModelicaEquation.allInstances()->select(mc | mc.base_Constraint = self)->first().isInitial;

helper context MMuml!NamedElement def: getStateMachine() : MMuml!StateMachine = 
	if self.owner.oclIsTypeOf(MMuml!StateMachine) then
		self.owner
	else
		self.owner.getStateMachine()
	endif;

helper def:initializeTriggerEvent(seqLifeline:Sequence(MMuml!Lifeline), size:Integer):String =
	if(size=seqLifeline.size())then
		thisModule.getEventsFromLifeline(seqLifeline->at(size).represents.type, seqLifeline->at(size).represents, 1)
	else
		thisModule.initializeTriggerEvent(seqLifeline, size + 1).concat(thisModule.getEventsFromLifeline(seqLifeline->at(size).represents.type, seqLifeline->at(size).represents, 1))
	endif;
	
helper def:getEventsFromLifeline(c:MMuml!Class, p:MMuml!Property, size:Integer) : String = 
	if(size=MMuml!CallEvent.allInstances()->select(ce | c.ownedOperation->exists(o | o = ce.operation)).size()) then
		p.name + '.' + MMuml!CallEvent.allInstances()->select(ce | c.ownedOperation->exists(o | o = ce.operation))->at(size).name + ' := false;\n'
	else
		thisModule.getEventsFromLifeline(c, p, size + 1).concat(p.name + '.' + MMuml!CallEvent.allInstances()->select(ce | c.ownedOperation->exists(o | o = ce.operation))->at(size).name + ' := false;\n')
	endif;

helper def: isMaxTimeValue(value:Integer, seqDurationConstraint:Sequence(MMuml!DurationConstraint)) : Boolean = 
	if seqDurationConstraint->exists(dc | dc.specification.max.expr.value > value) then
		false
	else 
		true
	endif;

helper def: getModelicaGuardIndex(constraint: MMuml!Constraint, index:Integer): Integer = 
	if constraint.specification.language->at(index).toString() = 'Modelica' then
		index 
	else
		thisModule.getModelicaGuardIndex(constraint, index + 1)
	endif;

helper def: getModelicaGuardBody(constraint:MMuml!Constraint): String = 
	constraint.specification.body->at(thisModule.getModelicaGuardIndex(constraint, 1));

helper def: getModelicaEffectIndex(ob:MMuml!OpaqueBehavior, index:Integer): Integer = 
	if ob.language->at(index).toString() = 'Modelica' then
		index 
	else
		thisModule.getModelicaEffectIndex(ob, index + 1)
	endif;

helper def: getModelicaEffectBody(ob:MMuml!OpaqueBehavior): String = 
	ob.body->at(thisModule.getModelicaEffectIndex(ob, 1));
------------------------------------------------------------------------
---------------------------------BDD------------------------------------
------------------------------------------------------------------------
rule Model2Model{
	from sysml: MMuml!Model(
		sysml.oclIsTypeOf(MMuml!Model) 
	) 
	to  modelica_model: MMmodelica!ModelicaModel(
		name <- sysml.name
	)
}

abstract rule Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		not thisModule.isConstraintBlockStereotyped(sysml) and
		sysml.isModelicaClassDefinitionStereotyped()
	)
	to modelica: MMmodelica!ModelicaClassDefinition(
		name <- sysml.name,
		isModelicaEncapsulated <- sysml.getIsModelicaEncapsulated(), 
		isFinal <- sysml.getIsFinal(), 
		isPartial <- sysml.getIsPartial(), 
		isReplaceable <- sysml.getIsReplaceable()
	)
}

rule Package2Package1 {
	from uml:MMuml!Package(
		not uml.owner.oclIsTypeOf(MMuml!Package) and
		not uml.oclIsTypeOf(MMuml!Model)
	)	
	to modelica: MMmodelica!Package(
		name <- uml.name,
		withinClause <- uml.getWithinClause(), 
		ownerModel <- uml.getModel()
	)
}

rule Package2Package2 {
	from uml:MMuml!Package(
		uml.owner.oclIsTypeOf(MMuml!Package)	
	)	
	to modelica: MMmodelica!Package(
		name <- uml.name,
		withinClause <- uml.getWithinClause(), 
		ownerPackage <- uml.owner
	)
}

rule Block2Package_1 extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		not thisModule.isConstraintBlockStereotyped(sysml) and
		sysml.isModelicaPackageStereotyped() and
		not (sysml.owner.oclIsTypeOf(MMuml!Class) and thisModule.isBlockStereotyped(sysml.owner))
	)
	to modelica: MMmodelica!Package(
		withinClause <- sysml.getWithinClause(), 
		ownerModel <- sysml.getModel()
	)
}

rule Block2Package_2 extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		not thisModule.isConstraintBlockStereotyped(sysml) and
		sysml.isModelicaPackageStereotyped() and
		sysml.owner.oclIsTypeOf(MMuml!Class) and 
		thisModule.isBlockStereotyped(sysml.owner) and
		sysml.owner.isModelicaPackageStereotyped()
	)
	to modelica: MMmodelica!Package(
		withinClause <- sysml.getWithinClause(), 
		ownerPackage <- sysml.owner
		
	)
}

rule Block2Model extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		sysml.isModelicaModelStereotyped()
	)
	to modelica: MMmodelica!Model(
		ownerModel <- if(not thisModule.isBlockStereotyped(sysml.owner) and not sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(sysml.owner) or sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.owner
						else
							OclUndefined
						endif
	)						
}

rule Block2Block extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		sysml.isModelicaBlockStereotyped()
	)
	to modelica: MMmodelica!Block(
		ownerModel <- if(not thisModule.isBlockStereotyped(sysml.owner) and not sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(sysml.owner) or sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.owner
						else
							OclUndefined
						endif
	)						
}

rule Block2ModelicaConnector extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		sysml.isModelicaConnectorStereotyped()
	)
	to modelica: MMmodelica!Connector(
		isExpandable <- sysml.getIsExpandable(), 
		ownerPackage <- sysml.owner
	)
}

rule Block2ModelicaRecord extends Block2ModelicaClassDefinition{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml) and
		sysml.isModelicaRecordStereotyped()
	)
	to modelica: MMmodelica!Record(
		ownerModel <- if(not thisModule.isBlockStereotyped(sysml.owner) and not sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(sysml.owner) or sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.owner
						else
							OclUndefined
						endif	
	)
}

rule Enumeration2EnumerationType{
	from sysml: MMuml!Enumeration
	to modelica: MMmodelica!Enumeration(
		name <- sysml.name, 
		ownerModel <- if(not thisModule.isBlockStereotyped(sysml.owner) and not sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(sysml.owner) or sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.owner
						else
							OclUndefined
						endif
	)
}

rule EnumLiteral2EnumeLiteral{
	from sysml: MMuml!EnumerationLiteral
	to modelica: MMmodelica!EnumerationLiteral(
		name <- sysml.name, 
		enumeration <- sysml.enumeration
	)
}

rule ValueType2Type{
	from sysml: MMuml!DataType(
		sysml.isValueTypeStereotyped() and
		sysml.isModelicaTypeStereotyped()
	)
	to modelica: MMmodelica!Type(
		name <- sysml.name,
		isModelicaEncapsulated <- sysml.getIsModelicaEncapsulated(), 
		isFinal <- sysml.getIsFinal(), 
		isPartial <- sysml.getIsPartial(), 
		isReplaceable <- sysml.getIsReplaceable(),
		ownerModel <- if(not thisModule.isBlockStereotyped(sysml.owner) and not sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(sysml.owner) or sysml.owner.oclIsTypeOf(MMuml!Package))then
							sysml.owner
						else
							OclUndefined
						endif
	)
}

rule Generalization2ModelicaExtends{
	from sysml: MMuml!Generalization(
		sysml.isModelicaExtendsStereotyped()	
	)
	to modelica: MMmodelica!ExtendsClause(
		ownerModelicaClassDefinition <- sysml.owner, 
		extendedModelicaClass <- if(sysml.general.getQualifiedName().startsWith('Modelica::') or sysml.general.getQualifiedName().startsWith('SysML4Modelica::Types'))then
									OclUndefined
								else
									sysml.general
								endif, 
		visibility <- sysml.getVisibility(), 
		arraySize <- sysml.getArraySize(), 
		modification <- sysml.getModification(), 
		from_modelica_standard_library <-	if(sysml.general.getQualifiedName().startsWith('Modelica::'))then
												sysml.general.getQualifiedName().regexReplaceAll('::', '.')
											else
												OclUndefined
											endif, 
		from_modelica_primitive_types <-  if (sysml.general.getQualifiedName().startsWith('SysML4Modelica::Types::ModelicaPredefinedTypes')) then
											sysml.general.name
										  else
										  	OclUndefined
										  endif
	)
}

abstract rule Property2ModelicaComponent{
	from sysml: MMuml!Property(
		sysml.isModelicaComponentStereotyped()	
	)	
	to modelica: MMmodelica!ModelicaComponent(
		name <- sysml.name, 
		ownerModelicaClassDefinition <- sysml.owner, 
		conditionalExpression <- if(sysml.getConditionalExpression() = '' or sysml.getConditionalExpression().oclIsUndefined())then
									OclUndefined
								else
									sysml.getConditionalExpression()
								endif,
		isFinal <- sysml.getIsFinal(), 
		modification <- sysml.getModification(),
		isReplaceable <- sysml.getIsReplaceable(), 
		arraySize <- if (sysml.getArraySize()->size()<= 0) then Sequence{} else sysml.getArraySize() endif, 
		type_specifier <- sysml.type.getQualifiedName().regexReplaceAll('::', '.')
	)
}

rule Property2ModelicaValueProperty extends Property2ModelicaComponent{
	from sysml: MMuml!Property(
		not thisModule.isBlockStereotyped(sysml.type) and
		sysml.isModelicaValuePropertyStereotyped()
	)
	to modelica: MMmodelica!ModelicaValueProperty(
		visibility <- sysml.visibility, 
		causality <- sysml.getCausality(), 
		variability <- sysml.getVariability(), 
		flowFlag <- sysml.getFlowFlag(), 
		scope <- sysml.getScope(), 
		default_value <- if(sysml.getDefault() <> OclUndefined and sysml.getDefault() <> '')then
							if (sysml.type.oclIsTypeOf(MMuml!Enumeration)) then
								sysml.type.name + '.' + sysml.getDefault()
							else
								sysml.getDefault()
							endif
						else
							'null'
						endif, 
		
		type_specifier <- if(sysml.type.name='ModelicaReal')then
							'Real'
							else
								if(sysml.type.name='ModelicaBoolean')then
									'Boolean'
								else
									if(sysml.type.name='ModelicaStateSelect')then
										'StateSelect'
									else
										if(sysml.type.name='ModelicaInteger')then
											'Integer'
										else
											sysml.type.getQualifiedName().regexReplaceAll('::', '.')
										endif
									endif	
								endif
							endif
	)
}

rule FunctionBehavior2ModelicaFunction{
	from sysml: MMuml!FunctionBehavior(
		(sysml.owner.isModelicaPackageStereotyped() or sysml.owner.oclIsTypeOf(MMuml!Package)) and
		sysml.isModelicaFunctionStereotyped() and 
		not MMuml!Dependency.allInstances()->exists(d | d.isModelicaDerStereotyped() and d.client->first() = sysml)
	)
	to modelica: MMmodelica!Function(
		name <- sysml.name,
		isModelicaEncapsulated <- sysml.getIsModelicaEncapsulated(), 
		isPartial <- sysml.getIsPartial(),
		isFinal <- sysml.getIsFinal(), 
		isReplaceable <- sysml.getIsReplaceable(), 
		externalLanguage <- if(sysml.language->first() <> '' and not sysml.language.oclIsUndefined()) then
								sysml.language->first()
							else
								OclUndefined
							endif, 
		externalLibrary <- sysml.getExternalLibrary(), 
		externalInclude <- sysml.getExternalInclude(), 
		ownerPackage <- sysml.owner
	), 
	modelica_algorithm_section: MMmodelica!AlgorithmSection(
		ownerModelicaClassDefinition <- modelica
	), 
	modelica_algorithm: MMmodelica!Algorithm(
		body <- if(not sysml.body.oclIsUndefined())then
					sysml.body->first()
				else
					''
				endif, 
		algorithmsection <- modelica_algorithm_section
	)
}

rule FunctionParameter2ModelicaParameter{
	from sysml: MMuml!Parameter(
		sysml.owner.oclIsTypeOf(MMuml!FunctionBehavior) and
		sysml.isModelicaFunctionParameterStereotyped() and
		sysml.owner.isModelicaFunctionStereotyped()
	)
	to modelica: MMmodelica!ModelicaFunctionParameter(
		name <- sysml.name, 
		causality <- sysml.getCausality(), 
		modification <- sysml.getModification(), 
		isReplaceable <- sysml.getIsReplaceable(), 
		declarationEquation <- sysml.getDeclarationEquation(), 
		isFinal <- sysml.getIsFinal(), 
		arraySize <- sysml.getArraySize(), 
		variability <- sysml.getVariability(), 
		ownerFunction <- sysml.owner, 
		isProtected <- if (sysml.visibility <> #protected) then
							false
						else
							true
						endif,
		type_specifier <- if(sysml.type.name='ModelicaReal')then
							'Real'
							else
								if(sysml.type.name='ModelicaBoolean')then
									'Boolean'
								else
									if(sysml.type.name='ModelicaStateSelect')then
										'StateSelect'
									else
										if(sysml.type.name='ModelicaInteger')then
											'Integer'
										else
											sysml.type.getQualifiedName().regexReplaceAll('::', '.')
										endif
									endif	
								endif
							endif
	)
}

rule Dependency2DerivativeFunction{
	from sysml: MMuml!Dependency(
		sysml.isModelicaDerStereotyped()
	)
	to modelica: MMmodelica!DerFunction(
		der <- sysml.supplier->first(), 
		ownerPackage <- sysml.client->first().owner, 
		name <- sysml.client->first().name, 
		variable <- sysml.getVariable()
	)
}

rule Dependency2ConstrainedBy{
	from sysml: MMuml!Dependency(
		sysml.isModelicaConstrainedByStereotyped()
	)
	to modelica: MMmodelica!ConstrainedByClause(
		modification <- sysml.getModification(), 
		ownerInstance <- sysml.client->first(), 
		instanceForConstrainedBy <- sysml.supplier->first()
	)
}

rule Comment2Annotation{
	from sysml: MMuml!Comment(
		sysml.isModelicaAnnotationStereotyped()	
	)
	to modelica: MMmodelica!Annotation(
		ownerMCD <- sysml.annotatedElement->first(), 
		body <- sysml.body.toString()
	)
}
--------------------------------------------------------------------------
-----------------------------------IBD------------------------------------
--------------------------------------------------------------------------
rule Property2ModelicaPort extends Property2ModelicaComponent{
	from sysml: MMuml!Port(
		sysml.isModelicaPortStereotyped()
	)
	to modelica: MMmodelica!ModelicaPort(
		causality <- sysml.getCausality(), 
		type_connector <- 	if(sysml.type.isModelicaConnectorStereotyped())then
								sysml.type
							else
								OclUndefined
							endif, 
		type_specifier <- if(sysml.type.isModelicaConnectorStereotyped() and not sysml.type.getQualifiedName().startsWith('Modelica::'))then
								thisModule.resolveTemp(sysml.type.owner, 'modelica').withinClause.regexReplaceAll('/', '.')
								+'.'+thisModule.resolveTemp(sysml.type.owner, 'modelica').name
								+'.'+sysml.type.name
							else
								sysml.type.getQualifiedName().regexReplaceAll('::', '.')
							endif
	)
}



rule Property2ModelicaPart extends Property2ModelicaComponent{
	from sysml: MMuml!Property(
		thisModule.isBlockStereotyped(sysml.type) and
		sysml.isModelicaPartStereotyped()
	)
	to modelica: MMmodelica!ModelicaPart(
		visibility <- sysml.visibility, 
		scope <- sysml.getScope(), 
		type_part <- if((sysml.type.isModelicaClassStereotyped() or sysml.type.isModelicaModelStereotyped() or sysml.type.isModelicaBlockStereotyped()) and not sysml.type.getQualifiedName().startsWith('Modelica::'))then
							sysml.type
						else
							OclUndefined
						endif, 
		type_specifier <- if(not sysml.type.getQualifiedName().startsWith('Modelica::') and (sysml.type.isModelicaClassStereotyped() or sysml.type.isModelicaModelStereotyped() or sysml.type.isModelicaBlockStereotyped() or sysml.type.isModelicaConnectorStereotyped()))then
								thisModule.resolveTemp(sysml.type.owner, 'modelica').withinClause.regexReplaceAll('/', '.')
								+'.'+thisModule.resolveTemp(sysml.type.owner, 'modelica').name
								+'.'+sysml.type.name
							else
								sysml.type.getQualifiedName().regexReplaceAll('::', '.')
							endif, 
		modification <- sysml.getModification()
	)
}

--------------------------------------------------------------------------
---------------------------ALGORITHM SECTION------------------------------
--------------------------------------------------------------------------
unique lazy rule Block2AlgorithmSection{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml)	
	)
	to modelica: MMmodelica!AlgorithmSection(
		ownerModelicaClassDefinition <- sysml	
	)
}

rule OpaqueBehavior2Algorithm{
	from sysml: MMuml!OpaqueBehavior(
		sysml.owner.oclIsTypeOf(MMuml!Class) and
		not sysml.oclIsTypeOf(MMuml!FunctionBehavior)
	)
	to modelica: MMmodelica!Algorithm(
		body <- sysml.body->first(), 
		algorithmsection <- thisModule.Block2AlgorithmSection(sysml.owner)
	)
}
--------------------------------------------------------------------------
----------------------------EQUATION SECTION------------------------------
--------------------------------------------------------------------------
unique lazy rule Block2EquationSection{
	from sysml: MMuml!Class(
		thisModule.isBlockStereotyped(sysml)	
	)
	to modelica: MMmodelica!EquationSection(
		ownerModelicaClassDefinition <- sysml	
	)
}

rule Connector2ModelicaConnect_1{
	from sysml: MMuml!Connector(
		sysml.isModelicaConnectionStereotyped() and
		thisModule.isBlockStereotyped(sysml.owner) and
		sysml.end->at(1).role.oclIsTypeOf(MMuml!Port) and 
		sysml.end->at(2).role.oclIsTypeOf(MMuml!Port)
	)
	to modelica: MMmodelica!Connect(
		ownerEquationSection <- thisModule.Block2EquationSection(sysml.owner), 
		from <- if(not sysml.end->at(1).role.getQualifiedName().startsWith('Modelica::')) then
					sysml.end->at(1).role
				else
					OclUndefined
				endif, 
		to <- 	if(not sysml.end->at(2).role.getQualifiedName().startsWith('Modelica::')) then
					sysml.end->at(2).role
				else
					OclUndefined
				endif, 
		fromModelicaPart <- if(not sysml.end->at(1).partWithPort.oclIsUndefined()) then
								sysml.end->at(1).partWithPort	
							else
								OclUndefined
							endif, 
		toModelicaPart <- 	if(not sysml.end->at(2).partWithPort.oclIsUndefined()) then
								sysml.end->at(2).partWithPort
							else
								OclUndefined
							endif, 
		fromPort <- if(sysml.end->at(1).role.getQualifiedName().startsWith('Modelica::')) then
						sysml.end->at(1).role.name
					else
						OclUndefined
					endif, 
		toPort <- 	if(sysml.end->at(2).role.getQualifiedName().startsWith('Modelica::')) then
						sysml.end->at(2).role.name
					else
						OclUndefined
					endif
	)
}

rule Connector2ModelicaConnect_2{
	from sysml: MMuml!Connector(
		sysml.isModelicaConnectionStereotyped() and
		thisModule.isBlockStereotyped(sysml.owner) and
		(
			sysml.end->at(1).role.oclIsTypeOf(MMuml!Property) or
			sysml.end->at(2).role.oclIsTypeOf(MMuml!Property)
		)
	)
	to modelica: MMmodelica!Connect(
		ownerEquationSection <- thisModule.Block2EquationSection(sysml.owner), 
		fromPart <- if(sysml.end->at(1).oclIsTypeOf(MMuml!ConnectorEnd))then
						if(sysml.end->at(1).role.oclIsTypeOf(MMuml!Port))then
							sysml.end->at(1).partWithPort.name
						else
							sysml.end->at(1).role.name
						endif
					else
						sysml.end->at(1).propertyPath->first().name
					endif, 
		toPart <- if(sysml.end->at(2).oclIsTypeOf(MMuml!ConnectorEnd))then
						if(sysml.end->at(2).role.oclIsTypeOf(MMuml!Port))then
							sysml.end->at(2).partWithPort.name
						else
							sysml.end->at(2).role.name
						endif
					else
						sysml.end->at(2).propertyPath->first().name
					endif, 
		fromPort <- if(sysml.end->at(1).oclIsTypeOf(MMuml!ConnectorEnd))then
						if(sysml.end->at(1).role.oclIsTypeOf(MMuml!Port))then
							sysml.end->at(1).role.name
						else
							OclUndefined
						endif
					else
						sysml.end->at(1).role.name
					endif, 
		toPort <- if(sysml.end->at(2).oclIsTypeOf(MMuml!ConnectorEnd))then
						if(sysml.end->at(2).role.oclIsTypeOf(MMuml!Port))then
							sysml.end->at(2).role.name
						else
							OclUndefined
						endif
					else
						sysml.end->at(2).role.name
					endif
	)
}

rule Constraint2ModelicaEquation{
	from sysml: MMuml!Constraint(
		sysml.isModelicaEquationStereotyped() and
		sysml.specification.oclIsTypeOf(MMuml!LiteralString)
	)
	to modelica: MMmodelica!Equation(
		ownerEquationSection <- thisModule.Block2EquationSection(sysml.owner), 
		isInitial <- sysml.getIsInitial(), 
		body <- sysml.specification.value.toString()
	)
}

--------------------------------------------------------------------------
--------------------------STATEMACHINE DIAGRAM----------------------------
--------------------------------------------------------------------------
rule Region2AlgorithmSection{
	from region: MMuml!Region(
		region.namespace.oclIsTypeOf(MMuml!StateMachine)	
	)
	to algorithmSection: MMmodelica!AlgorithmSection(
		ownerModelicaClassDefinition <- region.namespace.owner	
	)
}

rule InitialState2ModelicaPart{
	from initialState: MMuml!Pseudostate(
		initialState.kind = #initial and
		initialState.owner.oclIsTypeOf(MMuml!Region)
	)
	to part: MMmodelica!ModelicaPart(
		name <- initialState.name,
		ownerModelicaClassDefinition <- initialState.getStateMachine().owner, 
		type_specifier <- 'Boolean'
	), 
	whenStatement: MMmodelica!Algorithm(
		algorithmsection <- initialState.owner, --thisModule.Block2AlgorithmSection(initialState.getStateMachine().owner), 
		body <- 'when initial() then\n'+
				'	'+initialState.name+' := true;\n'+
				'end when;\n'
	)
}
rule State2ModelicaPart{
	from simpleState: MMuml!State(
		not simpleState.oclIsTypeOf(MMuml!FinalState) and
		not simpleState.isComposite and
		simpleState.submachine.oclIsUndefined()	and
		simpleState.owner.oclIsTypeOf(MMuml!Region)
	)
	to part: MMmodelica!ModelicaPart(
		name <- simpleState.name,
		ownerModelicaClassDefinition <- simpleState.getStateMachine().owner, 
		type_specifier <- 'Boolean'
	)
}

rule Trigger2ModelicaPart{
	from trigger: MMuml!Trigger	
	to part: MMmodelica!ModelicaPart(
		name <- trigger.event.name, 
		ownerModelicaClassDefinition <- trigger.getStateMachine().owner, 
		type_specifier <- 'Boolean'
	)
}

rule Transition2Algorithm{
	from sysml: MMuml!Transition(
		sysml.kind <> #internal and
		sysml.getStateMachine().owner.oclIsTypeOf(MMuml!Class) and
		sysml.owner.oclIsTypeOf(MMuml!Region)
	)	
	to whenStatement: MMmodelica!Algorithm(
		algorithmsection <- sysml.owner, --thisModule.Block2AlgorithmSection(sysml.getStateMachine().owner),
		body <- 'when pre('+sysml.source.name+')' + 
			
			if not sysml.guard.oclIsUndefined() then 
				if sysml.guard.oclIsTypeOf(MMuml!Constraint) then
					if sysml.guard.specification.language->exists(l | l.toString() = 'Modelica') then
						' and ' + thisModule.getModelicaGuardBody(sysml.guard)
					else
						''
					endif
				else
					''
				endif
			else
				''
			endif+
			if not sysml.trigger->first().oclIsUndefined() then
				' and ' + sysml.trigger->first().event.name
			else
				''
			endif
			+' then\n'+ 
			if not sysml.target.oclIsTypeOf(MMuml!FinalState) then
				'	'+sysml.source.name + ':= false;\n' +
				'	'+sysml.target.name + ':= true;\n'
			else
				if sysml.target.oclIsTypeOf(MMuml!FinalState) then 
					'	'+sysml.source.name + ':= false;\n'
				else
					''
				endif
			endif +
			if not sysml.effect.oclIsUndefined() then 
				if sysml.effect.oclIsTypeOf(MMuml!OpaqueBehavior) then
					if sysml.effect.language->exists(l | l.toString() = 'Modelica') then
						'	' + thisModule.getModelicaEffectBody(sysml.effect)
					else
						''
					endif
				else
					''
				endif
			else
				''
			endif
			+'\n'+'end when;\n'
	)
}

--------------------------------------------------------------------------
--------------------------SEQUENCE DIAGRAM----------------------------
--------------------------------------------------------------------------
--These rules enables simulations of test cases specified with UML 
--sequence diagrams. Interaction is transformed into a Modelica model 
--containing Modelica parts derived from life lines. A test case is  
--then specified with a Modelica algorithm that is derived from 
--asynchronous messages and duration constraints on action execution 
--specification. Typically, "when" statements on time events that trigger 
--specific action of the plant model. 
--
--EXAMPLE:
--model TestCase
--	Plant plant1;
-- 	AnotherPlant plant2;
--algorithm
--	when initial() then
--		plant.trigger1 := false;
--		plant2.trigger2 := false;
--		[..]
--	when time > 0 and time <  60 then
--		plant1.trigger1 := true;
--		plant2.trigger2 := true;
--		[..]
--	end when;
--	[..]
--end TestCase;
--
--We assess that, at the simulation level, time must be the only variable that triggers events. 
--There is two main arguments to justify this choice: 
--	-First time is the common dimension to each known real physical phenomenon. Every equation 
--	 of the plant model are resolved in function of time.
--	-Every human interactions with physical machines can be modeled as a list of actions 
--	 upon the time line . 
-- 
--Modeling constraints: 
--	-lifeline typed by existing part
--	-messageRecv on ActionExecutionSpecificationStart
--	-duration constraint on messageRecv and ActionExecutionSpecificationStop
--	-message.signature must be existing operation and this operation must be triggered by the system
--
--
-- Sequence diagrams are created during the concretization of abstract test cases generated by Phoenix.


rule Interaction2Model {
	from uml: MMuml!Interaction(
		uml.isModelicaModelStereotyped()	
	)
	to modelica: MMmodelica!Model(
		name <- uml.name, 
		ownerModel <- if(not thisModule.isBlockStereotyped(uml.owner) and not uml.owner.oclIsTypeOf(MMuml!Package))then
							uml.getModel()
						else
							OclUndefined
						endif, 
		ownerPackage <- if(thisModule.isBlockStereotyped(uml.owner) or uml.owner.oclIsTypeOf(MMuml!Package) and not uml.owner.oclIsTypeOf(MMuml!Model))then
							uml.owner
						else
							OclUndefined
						endif
	), 
	algorithmSection: MMmodelica!AlgorithmSection(
		ownerModelicaClassDefinition <- uml	
	), 
	algorithm: MMmodelica!Algorithm(
		algorithmsection <- algorithmSection, 
		body <- 'when initial() then\n' + 
			thisModule.initializeTriggerEvent(
				uml.lifeline->select(l | l.represents.isModelicaPartStereotyped() and l.represents.type.isModelicaModelStereotyped())
				, 1
			) +
			'end when;\n'
	)
}

unique lazy rule Interaction2AlgorithmSection{
	from uml: MMuml!Interaction
	to modelica: MMmodelica!AlgorithmSection(
		ownerModelicaClassDefinition <- uml	
	)
}

rule LifeLine2ModelicaPart{
	from uml: MMuml!Lifeline(
		if uml.represents.oclIsKindOf(MMuml!Property) then
			uml.represents.isModelicaPartStereotyped() and
			uml.represents.type.isModelicaModelStereotyped()
		else
			false
		endif
	)
	to modelicaPart: MMmodelica!ModelicaPart(
		ownerModelicaClassDefinition <- uml.owner, 
		type_part <- if((uml.represents.type.isModelicaClassStereotyped() or uml.represents.type.isModelicaModelStereotyped() or uml.represents.type.isModelicaBlockStereotyped()) and not uml.represents.type.getQualifiedName().startsWith('Modelica::'))then
							uml.represents.type
						else
							OclUndefined
						endif, 
		type_specifier <- if(not uml.represents.type.getQualifiedName().startsWith('Modelica::') and (uml.represents.type.isModelicaClassStereotyped() or uml.represents.type.isModelicaModelStereotyped() or uml.represents.type.isModelicaBlockStereotyped() or uml.represents.type.isModelicaConnectorStereotyped()))then
								thisModule.resolveTemp(uml.represents.type.owner, 'modelica').withinClause.regexReplaceAll('/', '.')
								+'.'+thisModule.resolveTemp(uml.represents.type.owner, 'modelica').name
								+'.'+uml.represents.type.name
							else
								uml.represents.type.getQualifiedName().regexReplaceAll('::', '.')
							endif, 
		name <- uml.represents.name
	)
}

rule Message2WhenStatement{
	from uml:MMuml!Message
	to whenStatement:MMmodelica!Algorithm(
		algorithmsection <- thisModule.resolveTemp(uml.owner, 'algorithmSection'), 
		body <- 'when time > ' + MMuml!DurationConstraint.allInstances()->select(d | d.owner = uml.owner and d.constrainedElement->exists(e | e = uml.receiveEvent))->first().specification.min.expr.value + ' and time <= ' + MMuml!DurationConstraint.allInstances()->select(d | d.constrainedElement->exists(e | e = uml.receiveEvent))->first().specification.max.expr.value + ' then \n' +
					thisModule.resolveTemp(MMuml!Lifeline.allInstances()->select(l | l.coveredBy->exists(c | c = uml.receiveEvent))->first(), 'modelicaPart').name + '.' +
					MMuml!CallEvent.allInstances()->select(e | e.operation = uml.signature)->first().name + ' := true;\n' +
				'end when;\n' +
				if thisModule.isMaxTimeValue(MMuml!DurationConstraint.allInstances()->select(d | d.constrainedElement->exists(e | e = uml.receiveEvent))->first().specification.max.expr.value, MMuml!DurationConstraint.allInstances()->select(d | d.owner = uml.owner)) then
					'when time > ' + MMuml!DurationConstraint.allInstances()->select(d | d.constrainedElement->exists(e | e = uml.receiveEvent))->first().specification.max.expr.value + ' then \n' +
					thisModule.initializeTriggerEvent(
						uml.owner.lifeline->select(l | l.represents.isModelicaPartStereotyped() and l.represents.type.isModelicaModelStereotyped())
						, 1
					)
					+'end when;\n'
				else
					''
				endif
	)
}

--------------------------------------------------------------------------
--------------------------REQUIREMENTS DIAGRAM----------------------------
--------------------------------------------------------------------------

rule Requirement2Comment {
	from
		sysmlRequirement: MMsysml!Requirement(
			sysmlRequirement.oclIsTypeOf(MMsysml!Requirement)
		)
	to
		comment: MMmodelica!Comment(
			ownerModelicaClassDefinition <- sysmlRequirement.satisfiedBy->first(),
			body <- '@ReqID: ' + sysmlRequirement.id + ' : ' + sysmlRequirement.text
		)		
}

--rule StateMachine2Algorithm{
--	from statemachine: MMuml!StateMachine(
--		statemachine.owner.oclIsTypeOf(MMuml!Class)	
--	)
--	to algorithmSection: MMmodelica!AlgorithmSection(
--		ownerModelicaClassDefinition <- statemachine.owner,
--		body <- ''
--	)
--}
--

--rule StateMachine2Record{
--	from statemachine: MMuml!StateMachine(
--		statemachine.owner.oclIsTypeOf(MMuml!Class)	
--	)
--	to recordStatemachine: MMmodelica!Record(
--		name <- 'SM_'+statemachine.name, 
--		ownerModelicaClassDefinition <- statemachine.owner, 
--		stateMachineElementType <- #statemachine
--	),
--	recordInitialState: MMmodelica!Record(
--		name <- 'InitialState', 
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		stateMachineElementType <- #initialstate
--	),
--	recordFinalState: MMmodelica!Record(
--		name <- 'FinalState', 
--		ownerModelicaClassDefinition <-recordStatemachine, 
--		stateMachineElementType <- #finalstate
--	),
--	recordSimpleState: MMmodelica!Record(
--		name <- 'SimpleState', 
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		stateMachineElementType <- #simplestate
--	), 
--	stateMachineInstance: MMmodelica!ModelicaPart(
--		name <- statemachine.name,
--		ownerModelicaClassDefinition <- statemachine.owner, 
--		type_part <- recordStatemachine, 
--		type_specifier <- recordStatemachine.name
--	),
--	recordStatemachineActive: MMmodelica!ModelicaValueProperty(
--		name <- 'active',
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		type_specifier <- 'Boolean'
--	),
--	recordStatemachineTimeAtActivation: MMmodelica!ModelicaValueProperty(
--		name <- 'timeAtActivation',
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		type_specifier <- 'Real'
--	),
--	recordStatemachineStime: MMmodelica!ModelicaValueProperty(
--		name <- 'stime',
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		type_specifier <- 'Real'
--	),
--	recordStatemachineSelfTransitionActivated: MMmodelica!ModelicaValueProperty(
--		name <- 'selfTransitionActivated',
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		type_specifier <- 'Boolean'
--	),
--	recordStatemachineStartBehaviour: MMmodelica!ModelicaValueProperty(
--		name <- 'startBehaviour',
--		ownerModelicaClassDefinition <- recordStatemachine, 
--		type_specifier <- 'Boolean'
--	),
--	recordInitialStateActive: MMmodelica!ModelicaValueProperty(
--		name <- 'active',
--		ownerModelicaClassDefinition <- recordInitialState, 
--		type_specifier <- 'Boolean'
--	),
--	recordInitialStateTimeAtActivation: MMmodelica!ModelicaValueProperty(
--		name <- 'timeAtActivation',
--		ownerModelicaClassDefinition <- recordInitialState, 
--		type_specifier <- 'Real'
--	),
--	recordInitialStateStime: MMmodelica!ModelicaValueProperty(
--		name <- 'stime',
--		ownerModelicaClassDefinition <- recordInitialState, 
--		type_specifier <- 'Real'
--	),
--	recordInitialStateSelfTransitionActivated: MMmodelica!ModelicaValueProperty(
--		name <- 'selfTransitionActivated',
--		ownerModelicaClassDefinition <- recordInitialState, 
--		type_specifier <- 'Boolean'
--	),
--	recordFinalStateActive: MMmodelica!ModelicaValueProperty(
--		name <- 'active',
--		ownerModelicaClassDefinition <- recordFinalState, 
--		type_specifier <- 'Boolean'
--	),
--	recordFinalStateTimeAtActivation: MMmodelica!ModelicaValueProperty(
--		name <- 'timeAtActivation',
--		ownerModelicaClassDefinition <- recordFinalState, 
--		type_specifier <- 'Real'
--	),
--	recordFinalStateStime: MMmodelica!ModelicaValueProperty(
--		name <- 'stime',
--		ownerModelicaClassDefinition <- recordFinalState, 
--		type_specifier <- 'Real'
--	),
--	recordFinalStateSelfTransitionActivated: MMmodelica!ModelicaValueProperty(
--		name <- 'selfTransitionActivated',
--		ownerModelicaClassDefinition <- recordFinalState, 
--		type_specifier <- 'Boolean'
--	),
--	recordSimpleStateActive: MMmodelica!ModelicaValueProperty(
--		name <- 'active',
--		ownerModelicaClassDefinition <- recordSimpleState, 
--		type_specifier <- 'Boolean'
--	),
--	recordSimpleStateTimeAtActivation: MMmodelica!ModelicaValueProperty(
--		name <- 'timeAtActivation',
--		ownerModelicaClassDefinition <- recordSimpleState, 
--		type_specifier <- 'Real'
--	),
--	recordSimpleStateStime: MMmodelica!ModelicaValueProperty(
--		name <- 'stime',
--		ownerModelicaClassDefinition <- recordSimpleState, 
--		type_specifier <- 'Real'
--	),
--	recordSimpleStateSelfTransitionActivated: MMmodelica!ModelicaValueProperty(
--		name <- 'selfTransitionActivated',
--		ownerModelicaClassDefinition <- recordSimpleState, 
--		type_specifier <- 'Boolean'
--	),
--	algorithmSection: MMmodelica!AlgorithmSection(
--		ownerModelicaClassDefinition <- statemachine.owner,
--		body <- ''
--	)
--}
--
--rule Region2Record{
--	from region: MMuml!Region
--	to recordRegion: MMmodelica!Record(
--		name <- region.stateMachine.name+'_'+region.name, 
--		ownerModelicaClassDefinition <- region.stateMachine, 
--		stateMachineElementType <- #region
--	), 
--	partRegion: MMmodelica!ModelicaPart(
--		name <- region.name, 
--		type_specifier <- recordRegion.name, 
--		ownerModelicaClassDefinition <- region.stateMachine
--	), 
--	numberOfActiveStates: MMmodelica!ModelicaValueProperty(
--		name <- 'numberOfActiveStates',
--		ownerModelicaClassDefinition <- recordRegion, 
--		type_specifier <- 'Integer'
--	)
--}
--
--rule InitialState2ModelicaPart{
--	from initialState: MMuml!Pseudostate(
--		initialState.kind = #initial	
--	)
--	to part: MMmodelica!ModelicaPart(
--		name <- initialState.name,
--		ownerModelicaClassDefinition <- initialState.owner, 
--		type_specifier <- thisModule.resolveTemp(initialState.getStateMachine(), 'recordInitialState').name 
--	)
--}
--
--rule FinalState2ModelicaPart{
--	from finalState: MMuml!FinalState
--	to part: MMmodelica!ModelicaPart(
--		name <- finalState.name,
--		ownerModelicaClassDefinition <- finalState.owner, 
--		type_specifier <- thisModule.resolveTemp(finalState.getStateMachine(), 'recordFinalState').name
--	)
--}
--